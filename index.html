<!DOCTYPE html>
<html lang="fa">
	<head>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@v33.003/Vazirmatn-font-face.css">
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>بازی ایر هاکی (تک‌نفره و دونفره)</title>
		<style>
			/* (این بخش بدون تغییر باقی می‌ماند) */
			html,body{direction: rtl;height:100%;margin:0;padding:0;background:#061428;color:#fff; font-feature-settings: "ss01"; font-family: Vazirmatn, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
			#root{height:100%;display:flex;align-items:center;justify-content:center;overflow:hidden}
			canvas{display:block;cursor: none;}
			.ui { position:fixed;left:50%;transform:translateX(-50%);top:18px;z-index:30;display:flex;gap:18px;align-items:center;font-weight:700 }
			.scoreBox{backdrop-filter: blur(6px);background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));padding:10px 16px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.6);display:flex;gap:12px;align-items:center}
			.scoreNumber{font-size:26px;color:#ffd166}
			.label{font-size:13px;color:#cfe8ff;opacity:0.9}
			.modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(2,6,23,0.7), rgba(2,6,23,0.85));z-index:50}
			.modal .panel{background:linear-gradient(180deg,#08203a,#05304a);padding:24px;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.6);width:min(640px,92vw)}
			.modal h2{margin:0 0 6px 0;font-size:20px; text-align:center;}
			.big{font-size:38px;color:#ffd166}
			.btn{font-family: 'Vazirmatn';display:inline-block;padding:10px 16px;border-radius:10px;margin:8px;cursor:pointer;border:0;background:#0ea5a8;color:#002; font-weight:700}
			.ghost{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff}
			.fsPrompt{position:fixed;left:50%;top:70%;transform:translate(-50%,-50%);z-index:60;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:12px;border-radius:10px}
			@media (max-width:720px){.ui{top:10px}}
		</style>
	</head>
	<body>
		<div id="root">
			<canvas id="c"></canvas>
		</div>

		<div class="ui" aria-hidden>
			<div class="scoreBox">
				<div style="text-align:center">
					<div class="label">بازیکن→</div>
					<div class="scoreNumber" id="scoreB">0</div>
				</div>
				<div style="text-align:center">
					<div class="label">زمان</div>
					<div class="scoreNumber" id="timer">00:00</div>
				</div>
				<div style="text-align:center">
					<div class="label" id="playerALabel">بازیکن←</div>
					<div class="scoreNumber" id="scoreA">0</div>
				</div>
			</div>
		</div>

		<div id="modal" class="modal">
			<div class="panel">
				<h2>بازی ایر هاکی</h2>
				<div style="display:flex;gap:12px;align-items:center;margin:12px 0; flex-wrap: wrap; justify-content: center;">
					<div style="flex:1; min-width: 180px;">
						<label style="font-size:13px">مدت بازی (دقیقه)</label>
						<select id="matchMinutes" style="font-feature-settings: 'ss01';font-family: 'Vazirmatn';width:100%;padding:8px;margin-top:6px;border-radius:8px">
							<option value="1">۱ دقیقه</option>
							<option value="2" selected>۲ دقیقه</option>
							<option value="3">۳ دقیقه</option>
							<option value="5">۵ دقیقه</option>
							<option value="10">۱۰  دقیقه</option>
						</select>
					</div>
					<div style="width:220px;text-align:center">
						<div style="font-size:12px;color:#cfe8ff">حالت بازی را انتخاب کنید:</div>
						<div style="margin-top:8px">
							<button id="startSinglePlayerBtn" class="btn">تک‌نفره</button>
							<button id="startTwoPlayerBtn" class="btn">دونفره</button>
						</div>
					</div>
				</div>
				<div style="color:#cfe8ff;opacity:0.9;font-size:13px; text-align:center; margin-bottom: 16px;">برای تجربه بهتر، <button id="fullscreenBtn" class="btn ghost" style="padding: 4px 8px; margin: 0;">تمام صفحه</button> کنید.</div>

				<div style="padding-top:16px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 14px; line-height: 1.7;">
					<div style="font-weight:700; margin-bottom:10px; font-size:16px; text-align:center;">دستورالعمل‌ها</div>
					<div style="display:flex; flex-wrap: wrap; gap: 20px; justify-content: center; text-align: right; color:#cfe8ff;">
						<div>
							<b style="color:yellow;">بازیکن راست (زرد):</b><br />
							حرکت: کلیدهای جهت ←↑↓→<br />
							ضربه: حرکت به سمت توپ یا دکمهٔ دسته
						</div>
						<div>
							<b style="color:red;">بازیکن چپ (قرمز):</b><br />
							حرکت: کلیدهای W A S D (در حالت دونفره)<br />
							ضربه: حرکت به سمت توپ یا دکمهٔ دسته
						</div>
					</div>
				</div>
			</div>
		</div>

		<script>
			// --- بازی Air Hockey: پیاده‌سازی با canvas 2D و WebAudio ---

			const canvas = document.getElementById('c');
			const ctx = canvas.getContext('2d');
			const modal = document.getElementById('modal');
			const startSinglePlayerBtn = document.getElementById('startSinglePlayerBtn');
			const startTwoPlayerBtn = document.getElementById('startTwoPlayerBtn');
			const fsBtn = document.getElementById('fullscreenBtn');
			const scoreAEl = document.getElementById('scoreA');
			const scoreBEl = document.getElementById('scoreB');
			const timerEl = document.getElementById('timer');
			const matchMinutesSelect = document.getElementById('matchMinutes');
			const playerALabel = document.getElementById('playerALabel');

			// --- وضعیت بازی ---
			const state = { running:false, scoreA:0, scoreB:0, matchTime: 120, timeLeft: 0, gameMode: 'singlePlayer' };

			// اندازه‌گیری و فول‌اسکرین
			function resize(){ canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
			window.addEventListener('resize',resize);
			resize();

			async function tryFullscreen(){
			  try{ if(document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen(); }
			  catch(e){ console.warn('fullscreen blocked',e);}
			}
			window.addEventListener('load',()=>{ /* tryFullscreen(); */ });
			fsBtn.addEventListener('click', tryFullscreen);

			let flashTimer = 0; let flashSide = null;
			let shakeTimer = 0; let shakeIntensity = 0;

			function tableCoords(w,h){
			  const padding = Math.min(w*0.06,60);
			  const left = padding, right = w-padding;
			  const top = h*0.18, bottom = h - h*0.08;
			  return {left,right,top,bottom,width:right-left,height:bottom-top};
			}

			let puck, paddleA, paddleB;
			function resetObjects(){
			  const {left,right,top,bottom,width,height} = tableCoords(canvas.width,canvas.height);
			  puck = {x:(left+right)/2, y:(top+bottom)/2, r: Math.max(12, Math.min(28, width*0.02)), vx:0, vy:0, mass:1, maxSpeed:1400, rotation:0, angularVelocity:0};
			  paddleA = {x:left + width*0.15, y:(top+bottom)/2, r: Math.max(22, Math.min(44, width*0.03)), mass: 5, maxSpeed: 900, acceleration: 3500, vx:0, vy:0};
			  paddleB = {x:right - width*0.15, y:(top+bottom)/2, r: Math.max(22, Math.min(44, width*0.03)), mass: 5, maxSpeed: 900, acceleration: 3500, vx:0, vy:0};
			}
			resetObjects();

			const keys = {};
			window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; });
			window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

			function handleGamepadInput() {
			  const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
			  if (!gamepads) return;

			  const gp2 = gamepads[1] || gamepads[0];
			  if (gp2) {
			    let dx = gp2.axes[0]; let dy = gp2.axes[1];
			    if (Math.abs(dx) < 0.1) dx = 0; if (Math.abs(dy) < 0.1) dy = 0;
			    paddleB.vx += dx * paddleB.acceleration * 0.016;
			    paddleB.vy += dy * paddleB.acceleration * 0.016;
			  }

			  if (state.gameMode === 'twoPlayer') {
                  const gp1 = gamepads[0];
                  if (gp1) {
                    let dx = gp1.axes[0]; let dy = gp1.axes[1];
                    if (Math.abs(dx) < 0.1) dx = 0; if (Math.abs(dy) < 0.1) dy = 0;
                    paddleA.vx += dx * paddleA.acceleration * 0.016;
                    paddleA.vy += dy * paddleA.acceleration * 0.016;
                  }
              }
			}

			const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			function playClick(frequency=880, duration=0.06, volume=0.12){
			  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
			  o.type='sine'; o.frequency.setValueAtTime(frequency, audioCtx.currentTime);
			  g.gain.setValueAtTime(volume, audioCtx.currentTime);
			  o.connect(g); g.connect(audioCtx.destination);
			  o.start(); o.stop(audioCtx.currentTime + duration);
			}
			function playWhistle(){
			  const t0 = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
			  o.type = 'sine'; o.frequency.setValueAtTime(2000 + Math.random()*500, t0);
			  g.gain.setValueAtTime(0.08, t0); g.gain.exponentialRampToValueAtTime(0.001, t0 + 0.8);
			  o.connect(g); g.connect(audioCtx.destination); o.start(t0); o.stop(t0 + 0.8);
			}
			const crowd = { gainNode: audioCtx.createGain(), running:false };
			function startCrowd(){
				if (crowd.running) return;
				const bufferSize = 2*audioCtx.sampleRate; const noiseBuffer = audioCtx.createBuffer(1,bufferSize, audioCtx.sampleRate);
				const output = noiseBuffer.getChannelData(0); for(let i=0;i<bufferSize;i++) output[i] = (Math.random()*2 - 1) * 0.4;
				const whiteNoise = audioCtx.createBufferSource(); whiteNoise.buffer = noiseBuffer; whiteNoise.loop = true;
				const noiseFilter = audioCtx.createBiquadFilter(); noiseFilter.type='lowpass'; noiseFilter.frequency.setValueAtTime(1100, audioCtx.currentTime);
				whiteNoise.connect(noiseFilter); noiseFilter.connect(crowd.gainNode); crowd.gainNode.connect(audioCtx.destination);
				crowd.gainNode.gain.setValueAtTime(0.03, audioCtx.currentTime); whiteNoise.start();
				crowd.source = whiteNoise; crowd.running = true; crowd.cheerTimer = setInterval(()=>{ playCheer(); }, 7000 + Math.random()*8000);
			}
			function stopCrowd(){ if(crowd.running){ crowd.source.stop(); clearInterval(crowd.cheerTimer); crowd.running=false; } }
			function playCheer(volume=0.06){
			  const t0 = audioCtx.currentTime; const g = audioCtx.createGain(); g.gain.setValueAtTime(0.001, t0); g.connect(audioCtx.destination);
			  [440,660,880].map(f=>{ const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(f + (Math.random()*80-40), t0); o.connect(g); o.start(); setTimeout(()=>o.stop(), 0.25*1000); });
			  g.gain.linearRampToValueAtTime(volume,t0+0.05); g.gain.exponentialRampToValueAtTime(0.0001,t0+0.7);
			}

			// --- هوش مصنوعی (اصلاح شده برای رفع باگ گیر کردن توپ) ---
			function aiControl(dt) {
				const {left, right, top, bottom, width, height} = tableCoords(canvas.width, canvas.height);
				const p = paddleA;
				const target = { x: p.x, y: p.y };

				// --- استراتژی تعیین هدف ---
				const isPuckInAIHalf = puck.x < left + width * 0.5;

				if (isPuckInAIHalf) {
					// **رفع باگ:** هوش مصنوعی حالا به طور فعال به سمت توپ حرکت می‌کند
					// تا به آن ضربه بزند، نه اینکه فقط در حالت دفاعی بماند.
					target.x = puck.x - p.r * 0.5; // هدف را کمی پشت توپ قرار می‌دهد تا برای ضربه آماده شود
					target.y = puck.y;
				} else {
					// وقتی توپ در زمین حریف است، به موقعیت دفاعی خنثی برمی‌گردد
					target.x = left + width * 0.2;
					target.y = (top + bottom) / 2;
				}

				// محدود کردن موقعیت هدف به نیمه زمین هوش مصنوعی
				target.x = Math.max(left + p.r, Math.min(left + width/2 - p.r, target.x));
				target.y = Math.max(top + p.r, Math.min(bottom - p.r, target.y));

				// --- محاسبه حرکت روان ---
				const dx = target.x - p.x;
				const dy = target.y - p.y;
				const dist = Math.hypot(dx, dy);
				
				const deadZone = 5.0;

				if (dist > deadZone) {
					const maxAISpeed = p.maxSpeed * 0.85;
					p.vx += (dx / dist) * maxAISpeed * dt * 10;
					p.vy += (dy / dist) * maxAISpeed * dt * 10;
				}

				// اعمال اصطکاک برای توقف نرم
				p.vx *= 0.89;
				p.vy *= 0.89;

				// محدود کردن سرعت نهایی
				const currentSpeed = Math.hypot(p.vx, p.vy);
				if (currentSpeed > p.maxSpeed * 0.85) {
					const k = (p.maxSpeed * 0.85) / currentSpeed;
					p.vx *= k; p.vy *= k;
				}
			}


			function stepPhysics(dt){
			  const {left,right,top,bottom,width,height} = tableCoords(canvas.width,canvas.height);

			  const move = (p, upKey, downKey, leftKey, rightKey)=>{
			    const damping = 0.94;
			    let inputX = 0, inputY = 0;
			    if(keys[upKey]) inputY -= 1; if(keys[downKey]) inputY += 1;
			    if(keys[leftKey]) inputX -= 1; if(keys[rightKey]) inputX += 1;

			    if (inputX !== 0 || inputY !== 0) {
			        const len = Math.hypot(inputX, inputY);
			        p.vx += (inputX / len) * p.acceleration * dt;
			        p.vy += (inputY / len) * p.acceleration * dt;
			    } else {
			        p.vx *= damping; p.vy *= damping;
			    }

                const currentSpeed = Math.hypot(p.vx, p.vy);
                if (currentSpeed > p.maxSpeed) { const k = p.maxSpeed / currentSpeed; p.vx *= k; p.vy *= k; }

			    p.x += p.vx * dt; p.y += p.vy * dt;
			    const minX = p===paddleA ? left + 8 : left + width/2 + 8;
			    const maxX = p===paddleA ? left + width/2 - 8 : right - 8;
			    p.x = Math.max(minX + p.r, Math.min(maxX - p.r, p.x));
			    p.y = Math.max(top + p.r, Math.min(bottom - p.r, p.y));
			  };

			  if (state.gameMode === 'twoPlayer') {
				  move(paddleA,'w','s','a','d');
			  } else {
				  aiControl(dt);
                  // حرکت فیزیکی هوش مصنوعی
                  paddleA.x += paddleA.vx * dt;
                  paddleA.y += paddleA.vy * dt;
                  paddleA.x = Math.max(left + paddleA.r, Math.min(left + width / 2 - paddleA.r, paddleA.x));
                  paddleA.y = Math.max(top + paddleA.r, Math.min(bottom - paddleA.r, paddleA.y));
			  }
			  move(paddleB,'arrowup','arrowdown','arrowleft','arrowright');

			  puck.x += puck.vx * dt; puck.y += puck.vy * dt; puck.rotation += puck.angularVelocity * dt;

			  const friction = 0.995 ** (dt*60);
			  puck.vx *= friction; puck.vy *= friction; puck.angularVelocity *= friction;
			  if(Math.hypot(puck.vx,puck.vy) < 6) { puck.vx = 0; puck.vy = 0; }
              if(Math.abs(puck.angularVelocity) < 0.1) { puck.angularVelocity = 0; }

              const spinEffect = 0.06;
			  if(puck.y - puck.r < top){ puck.y = top + puck.r; puck.vy *= -0.9; puck.vx += puck.angularVelocity * spinEffect; playClick(600); }
			  if(puck.y + puck.r > bottom){ puck.y = bottom - puck.r; puck.vy *= -0.9; puck.vx -= puck.angularVelocity * spinEffect; playClick(600); }

			  const goalHeight = Math.min(160, height*0.32);
			  const goalTop = (top + bottom)/2 - goalHeight/2;
			  const goalBottom = (top + bottom)/2 + goalHeight/2;
			  if(puck.x - puck.r <= left){ if(puck.y > goalTop && puck.y < goalBottom){ scorePoint('B'); } else { puck.x = left + puck.r; puck.vx *= -0.9; playClick(440);} }
			  if(puck.x + puck.r >= right){ if(puck.y > goalTop && puck.y < goalBottom){ scorePoint('A'); } else { puck.x = right - puck.r; puck.vx *= -0.9; playClick(440); } }

			  function collideP(p){
			    const dx = puck.x - p.x; const dy = puck.y - p.y; const dist = Math.hypot(dx,dy);
			    const minD = puck.r + p.r;
			    if(dist < minD){
			      const nx = dx/dist, ny = dy/dist;
			      const overlap = minD - dist + 0.001; puck.x += nx * overlap; puck.y += ny * overlap;
                  const vdx = puck.vx - p.vx; const vdy = puck.vy - p.vy; const dot = vdx * nx + vdy * ny;
                  if (dot < 0) {
                    const restitution = 1.6;
                    const impulse = -(restitution) * dot / (1/puck.mass + 1/p.mass);
                    puck.vx += impulse * nx / puck.mass;
                    puck.vy += impulse * ny / puck.mass;
                    puck.angularVelocity += (p.vx * ny - p.vy * nx) * 0.002;
                  }
			    }
			  }
			  collideP(paddleA); collideP(paddleB);
			}

			function scorePoint(player){
			  if(player==='A') state.scoreA++; else state.scoreB++;
			  scoreAEl.textContent = state.scoreA; scoreBEl.textContent = state.scoreB;
			  flashTimer = 0.5; flashSide = player; shakeTimer = 0.3; shakeIntensity = 5;
			  playCheer(0.1); playWhistle();
			  const {left,right,top,bottom} = tableCoords(canvas.width,canvas.height);
			  puck.x = (left+right)/2; puck.y = (top+bottom)/2; puck.vx = (player==='A'? -220:220); puck.vy = 0; puck.angularVelocity = 0;
			}

			function draw(){
			  const w = canvas.width, h = canvas.height;
			  ctx.clearRect(0,0,w,h);
			  const g = ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,'#011121'); g.addColorStop(1,'#032a3b');
			  ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
			  const {left,right,top,bottom,width,height} = tableCoords(w,h);

			  ctx.save();
			  ctx.translate(left + width/2, (top+bottom)/2 + height*0.05);
			  const shadowW = width*1.04, shadowH = height*1.12;
			  const rad = ctx.createRadialGradient(0,0,shadowW*0.02,0,0,shadowW*0.6);
			  rad.addColorStop(0,'rgba(0,0,0,0.55)'); rad.addColorStop(1,'rgba(0,0,0,0)');
			  ctx.fillStyle = rad; ctx.beginPath(); ctx.ellipse(0,0,shadowW/2,shadowH/4,0,0,Math.PI*2); ctx.fill();
			  ctx.restore();

			  const tableGrad = ctx.createLinearGradient(0,top,0,bottom); tableGrad.addColorStop(0,'#56ccf2'); tableGrad.addColorStop(1,'#0077b6');
			  ctx.fillStyle = tableGrad; roundRect(ctx,left,top,width,height, 26); ctx.fill();
			  ctx.lineWidth = 6; ctx.strokeStyle = 'rgba(255,255,255,0.08)'; roundRect(ctx,left+3,top+3,width-6,height-6,22); ctx.stroke();

			  ctx.beginPath(); ctx.moveTo(left + width/2, top+12); ctx.lineTo(left + width/2, bottom-12); ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 3; ctx.stroke();
			  const goalHeight = Math.min(160, height*0.32);
			  const goalTop = (top + bottom)/2 - goalHeight/2;
			  ctx.fillStyle = 'rgba(0,0,0,0.12)'; roundRect(ctx,left-6,goalTop, 12, goalHeight,6); ctx.fill();
			  ctx.fillStyle = 'rgba(153,255,153,0.6)'; roundRect(ctx,left,goalTop,6,goalHeight,4); ctx.fill();
			  ctx.fillStyle = 'rgba(153,255,153,0.6)'; roundRect(ctx,right-6,goalTop,6,goalHeight,6); ctx.fill();
			  ctx.beginPath(); ctx.arc((left+right)/2, (top+bottom)/2, 8,0,Math.PI*2); ctx.fillStyle='rgba(153,255,153,0.18)'; ctx.fill();

			  drawPaddle(paddleA,'#ff6b6b','#731010');
			  drawPaddle(paddleB,'#ffd166','#6a4f00');
			  drawPuck();

			  if(flashTimer > 0) {
			    const opacity = flashTimer / 0.5;
			    ctx.fillStyle = `rgba(255, 255, 255, ${opacity * 0.7})`;
			    const {height} = tableCoords(w,h);
			    const goalHeight = Math.min(160, height*0.32);
			    const t = (tableCoords(w,h).top + tableCoords(w,h).bottom)/2 - goalHeight/2;
			    const flashX = flashSide === 'A' ? tableCoords(w,h).right - 20 : tableCoords(w,h).left;
			    roundRect(ctx, flashX, t, 20, goalHeight, 6);
			    ctx.fill();
			    flashTimer -= 1/60;
			  }

			  const shine = ctx.createLinearGradient(0,tableCoords(w,h).top,0,tableCoords(w,h).top+height*0.4); shine.addColorStop(0,'rgba(255,255,255,0.06)'); shine.addColorStop(1,'rgba(255,255,255,0)');
			  ctx.fillStyle = shine; roundRect(ctx,tableCoords(w,h).left+6,tableCoords(w,h).top+6,width-12, Math.min(72,height*0.28), 20); ctx.fill();
			}

            function drawPaddle(p, c, inner) {
                const shadowOffsetX = 6 + (p.vx / p.maxSpeed) * 4;
                const shadowOffsetY = 10 + (p.vy / p.maxSpeed) * 4;
                ctx.beginPath(); ctx.ellipse(p.x + shadowOffsetX, p.y + shadowOffsetY, p.r * 1.1, p.r * 0.5, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fill();
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                const g = ctx.createRadialGradient(p.x - p.r * 0.4, p.y - p.r * 0.4, p.r * 0.1, p.x, p.y, p.r);
                g.addColorStop(0, 'rgba(255,255,255,0.8)'); g.addColorStop(0.3, c); g.addColorStop(1, inner);
                ctx.fillStyle = g; ctx.fill();
                ctx.beginPath(); ctx.arc(p.x - p.r * 0.2, p.y - p.r * 0.2, p.r * 0.5, 0, Math.PI * 2);
                const highlight = ctx.createRadialGradient(p.x - p.r * 0.3, p.y - p.r * 0.3, 0, p.x - p.r * 0.2, p.y - p.r * 0.2, p.r * 0.5);
                highlight.addColorStop(0, 'rgba(255,255,255,0.7)'); highlight.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = highlight; ctx.fill();
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 3; ctx.stroke();
            }

			function drawPuck(){
			  const shadowOffsetX = 4 + (puck.vx / puck.maxSpeed) * 6; const shadowOffsetY = 8 + (puck.vy / puck.maxSpeed) * 6;
			  ctx.beginPath(); ctx.ellipse(puck.x + shadowOffsetX, puck.y + shadowOffsetY, puck.r*1.2, puck.r*0.5,0,0,Math.PI*2);
			  ctx.fillStyle='rgba(0,0,0,0.26)'; ctx.fill();
			  ctx.save(); ctx.translate(puck.x, puck.y); ctx.rotate(puck.rotation);
			  ctx.beginPath(); ctx.arc(0,0,puck.r,0,Math.PI*2);
			  const g = ctx.createRadialGradient(-puck.r*0.3, -puck.r*0.3, 0, 0, 0, puck.r);
			  g.addColorStop(0, '#f0f0f0'); g.addColorStop(0.5, '#444'); g.addColorStop(1, '#111');
			  ctx.fillStyle=g; ctx.fill();
			  ctx.beginPath(); ctx.arc(0,0,puck.r,0,Math.PI*2); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.stroke();
			  ctx.beginPath(); ctx.arc(0,0, puck.r*0.6,0,Math.PI*2); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1.5; ctx.stroke();
			  ctx.restore();
			}

			function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

			let last = performance.now();
			function loop(now){
			  const dt = Math.min(0.03,(now-last)/1000); last = now;
			  if(state.running){
			    handleGamepadInput();
			    stepPhysics(dt);
			  }
			  let offsetX = 0, offsetY = 0;
			  if(shakeTimer > 0){
			    offsetX = (Math.random() - 0.5) * shakeIntensity; offsetY = (Math.random() - 0.5) * shakeIntensity;
			    ctx.translate(offsetX, offsetY);
			    shakeTimer -= dt; shakeIntensity *= 0.95;
			  }
			  draw();
			  if(shakeTimer > 0){ ctx.translate(-offsetX, -offsetY); }
			  requestAnimationFrame(loop);
			}
			requestAnimationFrame(loop);

			let matchInterval = null;
			function startMatch(minutes, mode){
			  state.gameMode = mode;
			  playerALabel.textContent = mode === 'singlePlayer' ? 'هوش مصنوعی' : 'بازیکن ←';
			  if(audioCtx.state === 'suspended') audioCtx.resume();
			  startCrowd();
			  state.matchTime = Math.max(10, Math.floor(minutes*60)); state.timeLeft = state.matchTime; state.running = true; state.scoreA=0; state.scoreB=0; scoreAEl.textContent=0; scoreBEl.textContent=0;
			  timerEl.textContent = formatTime(state.timeLeft);
			  if(matchInterval) clearInterval(matchInterval);
			  matchInterval = setInterval(()=>{
			    state.timeLeft -= 1; timerEl.textContent = formatTime(state.timeLeft);
			    if(state.timeLeft <= 0){ endMatch(); }
			  },1000);
			}
			function endMatch(){
			  state.running=false; stopCrowd(); if(matchInterval) clearInterval(matchInterval);
			  modal.style.display = 'flex';
			  const winnerA = state.gameMode === 'singlePlayer' ? 'هوش مصنوعی' : 'بازیکن چپ';
			  const winner = state.scoreA > state.scoreB ? `${winnerA} پیروز شد!` : (state.scoreB > state.scoreA ? 'بازیکن راست پیروز شد!' : 'تساوی!');
			  modal.querySelector('.panel').innerHTML = `
			    <h2 style="text-align:center">پایان مسابقه</h2>
			    <div style="font-size:32px;margin:10px 0;color:#ffd166; text-align:center;">${winner}</div>
			    <div style="display:flex;gap:12px;margin:10px 0; justify-content:center;">
			      <div class="scoreBox">
			        <div style="text-align:center"><div class="label">→ بازیکن</div><div class="scoreNumber">${state.scoreB}</div></div>
			      </div>
			      <div class="scoreBox">
			        <div style="text-align:center"><div class="label">${winnerA}</div><div class="scoreNumber">${state.scoreA}</div></div>
			      </div>
			     </div>
			    <div style="margin-top:10px; text-align:center;">
			      <button onclick="location.reload()" class="btn">بازی مجدد</button>
			    </div>
			  `;
			}

			function formatTime(s){ const m = Math.floor(s/60); const sec = s%60; return String(m).padStart(2,'0')+':' + String(sec).padStart(2,'0'); }

			function startGame(mode) {
			    const minutes = Number(matchMinutesSelect.value || 2);
				modal.style.display = 'none';
				resize(); resetObjects();
				try{ if(audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
				startMatch(minutes, mode);
			}

			startSinglePlayerBtn.addEventListener('click', () => startGame('singlePlayer'));
			startTwoPlayerBtn.addEventListener('click', () => startGame('twoPlayer'));


			canvas.addEventListener('touchstart', e=>{ e.preventDefault(); for(const t of e.changedTouches){ activeTouch[t.identifier] = {id:t.identifier}; } },{passive:false});
			canvas.addEventListener('touchmove', e=>{
			  e.preventDefault(); const rect = canvas.getBoundingClientRect(); for(const t of e.changedTouches){ const pos = {x: t.clientX - rect.left, y: t.clientY - rect.top};
			      const dA = Math.hypot(pos.x - paddleA.x, pos.y - paddleA.y); const dB = Math.hypot(pos.x - paddleB.x, pos.y - paddleB.y);
			      if (state.gameMode === 'twoPlayer' && dA < dB) {
					  paddleA.x = pos.x; paddleA.y = pos.y;
				  } else {
					  paddleB.x = pos.x; paddleB.y = pos.y;
				  }
			    }
			},{passive:false});

			window.addEventListener('orientationchange', ()=>{ resize(); resetObjects(); });
			document.addEventListener('selectstart', e=>e.preventDefault());
		</script>
	</body>
</html>
